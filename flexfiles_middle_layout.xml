<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible File Layout Type" anchor="sec:flexLayout">
  <t>
    The layout4 type is defined in <xref target="RFC5662" /> as follows:
  </t>

  <figure>
    <artwork>
    enum layouttype4 {
        LAYOUT4_NFSV4_1_FILES   = 1,
        LAYOUT4_OSD2_OBJECTS    = 2,
        LAYOUT4_BLOCK_VOLUME    = 3,
        LAYOUT4_FLEX_FILES      = 0x80000004
[[RFC Editor: please modify the LAYOUT4_FLEX_FILES
  to be the layouttype assigned by IANA]]
    };
   
    struct layout_content4 {
        layouttype4             loc_type;
        opaque                  loc_body&lt;&gt;;
    };
   
    struct layout4 {
        offset4                 lo_offset;
        length4                 lo_length;
        layoutiomode4           lo_iomode;
        layout_content4         lo_content;
    };
    </artwork>
  </figure>

  <t>
    This document defines structure associated with the layouttype4
    value LAYOUT4_FLEX_FILES.  <xref target="RFC5661" /> specifies
    the loc_body structure as an XDR type "opaque".  The opaque
    layout is uninterpreted by the generic pNFS client layers, but
    obviously must be interpreted by the Flexible File Layout Type
    implementation.  This section defines the structure of this
    opaque value, ff_layout4.
  </t>

  <section title="ff_layout4" anchor="ff_layout4">
    <figure>
      <artwork>
/// struct ff_data_server4 {
///     deviceid4               ffds_deviceid;
///     uint32_t                ffds_efficiency;
///     stateid4                ffds_stateid;
///     nfs_fh4                 ffds_fhandle;
///     opaque_auth             ffds_auth;
/// };
///
      </artwork>
    </figure>

    <figure>
      <artwork>
/// struct ff_mirror4 {
///     ff_data_server4         ffm_data_servers&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <figure>
      <artwork>
/// struct ff_layout4 {
///     length4                 ffl_stripe_unit;
///     ff_mirror4              ffl_mirrors&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
      The ff_layout4 structure specifies a layout over a set of
      mirrored copies of the data file.  This mirroring protects
      against loss of data files.
    </t>

    <t>
      It is possible that the file is concatenated from more than
      one layout segment.  Each layout segment MAY represent different
      striping parameters, applying respectively only to the layout
      segment byte range.
    </t>

    <t>
      The ffl_stripe_unit field is the stripe unit size in use for
      the current layout segment. The number of stripes is given
      inside each mirror by the number of elements in ffm_data_servers.
      If the number of stripes is one, then the value for ffl_stripe_unit
      MUST default to zero.  The only supported mapping scheme is
      sparse and is detailed in <xref target='sec:sparseStriping' />.
      Note that there is an assumption here that both the stripe
      unit size and the number of of stripes is the same across all
      mirrors.
    </t>

    <t>
      The ffl_mirrors field is the array of mirrored storage devices
      which provide the storage for the current stripe, see 
      <xref target='fig:ff_layout' />.
    </t>

    <figure anchor="fig:ff_layout">
      <artwork>
                   +-----------+
                   |           |
                   |           |
                   |   File    |
                   |           |
                   |           |
                   +-----+-----+
                         |
            +------------+------------+
            |                         |
       +----+-----+             +-----+----+
       | Mirror 1 |             | Mirror 2 |
       +----+-----+             +-----+----+
            |                         |
       +-----------+            +-----------+
       |+-----------+           |+-----------+
       ||+-----------+          ||+-----------+
       +||  Storage  |          +||  Storage  |
        +|  Devices  |           +|  Devices  |
         +-----------+            +-----------+
      </artwork>
    </figure>

    <t>
      The ffs_mirrors field represents an array of state information
      for each mirrored copy of the file. Each element is described
      by a ff_mirror4 type.
    </t>

    <t>
      ffds_deviceid provides the deviceid of the storage device
      holding the data file.
    </t>

    <t>
      ffds_fhandle provides the filehandle of the data file on the
      given storage device. For tight coupling, ffds_stateid provides
      the stateid to be used by the client to access the file. For
      loose coupling and a NFSv4 storage device, the client may use
      an anonymous stateid to perform I/O on the storage device as
      there is no use for the metadata server stateid (no control
      protocol). In such a scenario, the server MUST set the
      ffds_stateid to be zero.
    </t>

    <t>
      For loosely coupled storage devices, ffds_auth provides the
      RPC credentials to be used by the client to access the data
      files.  For tightly coupled storage devices, the server SHOULD
      use the AUTH_NONE flavor and a zero length opaque body to
      minimize the returned structure length.  I.e., if
      ffda_tightly_coupled (see <xref target='ff_device_addr' />)
      is set, then the client MUST ignore ffds_auth in this case.
    </t>

    <t>
      ffds_efficiency describes the metadata server's evaluation
      as to the effectiveness of each mirror. Note that this is per
      layout and not per device as the metric may change due to
      perceived load, availability to the metadata server, etc.
      Higher values denote higher perceived utility. The way the
      client can select the best mirror to access is discussed in
      <xref target="ss:select_mirror" />.
    </t>
  </section>
</section>
