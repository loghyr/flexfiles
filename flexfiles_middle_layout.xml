<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible File Layout Type" anchor="sec:flexLayout">
  <t>
    The layout4 type is defined in <xref target="RFC5662" /> as follows:
  </t>

  <figure>
    <artwork>
    enum layouttype4 {
        LAYOUT4_NFSV4_1_FILES   = 1,
        LAYOUT4_OSD2_OBJECTS    = 2,
        LAYOUT4_BLOCK_VOLUME    = 3,
        LAYOUT4_FLEX_FILES      = 4
[[RFC Editor: please modify the LAYOUT4_FLEX_FILES
  to be the layouttype assigned by IANA]]
    };
   
    struct layout_content4 {
        layouttype4             loc_type;
        opaque                  loc_body&lt;&gt;;
    };
   
    struct layout4 {
        offset4                 lo_offset;
        length4                 lo_length;
        layoutiomode4           lo_iomode;
        layout_content4         lo_content;
    };
    </artwork>
  </figure>

  <t>
    This document defines structure associated with the layouttype4
    value LAYOUT4_FLEX_FILES.  <xref target="RFC5661" /> specifies
    the loc_body structure as an XDR type "opaque".  The opaque
    layout is uninterpreted by the generic pNFS client layers, but
    obviously must be interpreted by the Flexible File Layout Type
    implementation.  This section defines the structure of this
    opaque value, ff_layout4.
  </t>

  <section title="ff_layout4" anchor="ff_layout4">
    <figure>
      <artwork>
/// struct ff_mirror4 {
/// 	deviceid4		ffm_deviceid;
/// 	nfs_fh4			ffm_fhandle;
/// 	stateid4		ffm_stateid;
/// 	opaque_auth		ffm_auth;
/// };
///
      </artwork>
    </figure>

    <figure>
      <artwork>
/// struct ff_stripe4 {
/// 	ff_mirror4		ffs_mirrors&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <figure>
      <artwork>
/// struct ff_layout4 {
///     length4                 ffl_stripe_unit;
///     uint32_t                ffl_mirror_efficiency&lt;&gt;;
///     ff_stripe4              ffl_stripes&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
      The ff_layout4 structure specifies a layout over a set of
      mirrored copies of the data file.  This mirroring protects
      against loss of data files.
    </t>

    <t>
      It is possible that the file is concatenated from more than
      one layout segment.  Each layout segment MAY represent different
      striping parameters, applying respectively only to the layout
      segment byte range.
    </t>

    <t>
      The ffl_stripe_unit field is the stripe unit size in use for
      the current layout segment. The number of stripes is given
      by the number of elements in ffl_stripes. The only supported
      mapping scheme is sparse and is detailed in
      <xref target='sec:sparseStriping' />.
    </t>

    <t>
      The ffl_mirror_efficiency field is the array which describes the
      metadata server's evaluation as to the effectiveness of each
      mirror. Note that this is per layout and not per device as
      the metric may change due to perceived load, availability to
      the metadata server, etc.  Higher values denote higher perceived
      utility. The way the client can select the best mirror to
      access is discussed in <xref target="ss:select_mirror" />.
    </t>

    <t>
      The ffl_stripes field is the array of mirrored storage devices
      which provide the storage for the current stripe. I.e., as shown
      in <xref target='fig:ff_layout' />, each i'th storage device
      in ffl_stripes is part of the i'th mirror of the layout segment.
    </t>

    <figure anchor="fig:ff_layout">
      <artwork>
                   +-----------+
                   |           |
                   |           |
                   |   Server  |
                   |           |
                   |           |
                   +-----+-----+
                         |
            +------------+------------+
            |                         |
            |                         |
       +-----------+            +-----------+
       |+-----------+           |+-----------+
       ||+-----------+          ||+-----------+
       |||           |          |||           |
       +||  Storage  |          +||  Storage  |
        +|  Devices  |           +|  Devices  |
         +-----------+            +-----------+
      </artwork>
    </figure>

    <t>
      The ffs_mirrors field represents an array of state information
      for each mirrored copy of the file. Each element is described
      by a ff_mirror4 type.
    </t>

    <t>
      ffm_deviceid provides the deviceid of the storage device
      holding the data file.
    </t>

    <t>
      ffm_fhandle provides the filehandle of the data file on the
      given storage device. For tight coupling, ffm_stateid provides
      the stateid to be used by the client to access the file. For
      loose coupling and a NFSv4 storage device, the client may use
      an anonymous stateid to perform I/O on the storage device as
      there is no use for the metadata server stateid (no control
      protocol). In such a scenario, the server MUST set the
      ffm_stateid to be zero.
    </t>

    <t>
      For NFSv3 storage devices, ffm_auth provides the RPC credentials
      to be used by the client to access the data files.  For NFSv4.x
      storage devices, the server SHOULD use the AUTH_NONE flavor
      and a zero length opaque body to minimize the returned structure
      length.  The client MUST ignore ffm_auth in this case.

      <cref anchor='AI6 ' source='TH'>
        Even for tightly coupled systems, that cannot be correct!
      </cref>
    </t>
  </section>
</section>
