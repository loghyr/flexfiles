<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible File Layout Type" anchor="sec:flexLayout">
  <t>
    The layout4 type is defined in <xref target="RFC5662" /> as follows:
  </t>

  <t>
    &lt;CODE BEGINS&gt;
  </t>

  <figure>
    <artwork>
    enum layouttype4 {
        LAYOUT4_NFSV4_1_FILES   = 1,
        LAYOUT4_OSD2_OBJECTS    = 2,
        LAYOUT4_BLOCK_VOLUME    = 3,
        LAYOUT4_FLEX_FILES      = 4
[[RFC Editor: please modify the LAYOUT4_FLEX_FILES
  to be the layouttype assigned by IANA]]
    };
    </artwork>
  </figure>
   
  <figure>
    <artwork>
    struct layout_content4 {
        layouttype4             loc_type;
        opaque                  loc_body&lt;&gt;;
    };
    </artwork>
  </figure>
   
  <figure>
    <artwork>
    struct layout4 {
        offset4                 lo_offset;
        length4                 lo_length;
        layoutiomode4           lo_iomode;
        layout_content4         lo_content;
    };
    </artwork>
  </figure>

  <t>
    &lt;CODE ENDS&gt;
  </t>

  <t>
    This document defines structure associated with the layouttype4
    value LAYOUT4_FLEX_FILES.  <xref target="RFC5661" /> specifies
    the loc_body structure as an XDR type "opaque".  The opaque
    layout is uninterpreted by the generic pNFS client layers, but
    obviously must be interpreted by the Flexible File Layout Type
    implementation.  This section defines the structure of this
    opaque value, ff_layout4.
  </t>

  <section title="ff_layout4" anchor="ff_layout4">

    <t>
      &lt;CODE BEGINS&gt;
    </t>

    <figure>
      <artwork>
/// struct ff_data_server4 {
///     deviceid4               ffds_deviceid;
///     uint32_t                ffds_efficiency;
///     stateid4                ffds_stateid;
///     nfs_fh4                 ffds_fh_vers&lt;&gt;;
///     fattr4_owner            ffds_user;
///     fattr4_owner_group      ffds_group;
/// };
///
      </artwork>
    </figure>

    <figure>
      <artwork>
/// struct ff_mirror4 {
///     ff_data_server4         ffm_data_servers&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <figure>
      <artwork>
/// struct ff_layout4 {
///     length4                 ffl_stripe_unit;
///     ff_mirror4              ffl_mirrors&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
      &lt;CODE ENDS&gt;
    </t>

    <t>
      The ff_layout4 structure specifies a layout over a set of
      mirrored copies of the data file.  This mirroring protects
      against loss of data files.
    </t>

    <t>
      It is possible that the file is concatenated from more than
      one layout segment.  Each layout segment MAY represent different
      striping parameters, applying respectively only to the layout
      segment byte range.
    </t>

    <t>
      The ffl_stripe_unit field is the stripe unit size in use for
      the current layout segment. The number of stripes is given
      inside each mirror by the number of elements in ffm_data_servers.
      If the number of stripes is one, then the value for ffl_stripe_unit
      MUST default to zero.  The only supported mapping scheme is
      sparse and is detailed in <xref target='sec:sparseStriping' />.
      Note that there is an assumption here that both the stripe
      unit size and the number of stripes is the same across all
      mirrors.
    </t>

    <t>
      The ffl_mirrors field is the array of mirrored storage devices
      which provide the storage for the current stripe, see 
      <xref target='fig:ff_layout' />.
    </t>

    <figure anchor="fig:ff_layout">
      <artwork>
                   +-----------+
                   |           |
                   |           |
                   |   File    |
                   |           |
                   |           |
                   +-----+-----+
                         |
            +------------+------------+
            |                         |
       +----+-----+             +-----+----+
       | Mirror 1 |             | Mirror 2 |
       +----+-----+             +-----+----+
            |                         |
       +-----------+            +-----------+
       |+-----------+           |+-----------+
       ||+-----------+          ||+-----------+
       +||  Storage  |          +||  Storage  |
        +|  Devices  |           +|  Devices  |
         +-----------+            +-----------+
      </artwork>
    </figure>

    <t>
      The ffs_mirrors field represents an array of state information
      for each mirrored copy of the file. Each element is described
      by a ff_mirror4 type.
    </t>

    <t>
      ffds_deviceid provides the deviceid of the storage device
      holding the data file.
    </t>

    <t>
      ffds_fh_vers is an array of filehandles of the data file
      matching to the available NFS versions on the given storage
      device.  There MUST be exactly as many elements in ffds_fh_vers
      as there are in ffda_versions. Each element of the array
      corresponds to each ffdv_version and ffdv_minorversion provided
      for the device.  The array allows for server implementations
      which have different filehandles for different version and
      minor version combinations. See <xref target='layout:versioning' />
      for how to handle versioning issues between the client and
      storage devices.
    </t>

    <t>
      For tight coupling, ffds_stateid provides
      the stateid to be used by the client to access the file. For
      loose coupling and a NFSv4 storage device, the client may use
      an anonymous stateid to perform I/O on the storage device as
      there is no use for the metadata server stateid (no control
      protocol). In such a scenario, the server MUST set the
      ffds_stateid to be zero.
    </t>

    <t>
      For loosely coupled storage devices, ffds_user and ffds_group
      provide the synthetic user and group to be used in the RPC
      credentials that the client presents to the storage device
      to access the data files.  For tightly coupled storage devices,
      the user and group on the storage device will be the same as
      on the metadata server.  I.e., if ffdv_tightly_coupled (see
      <xref target='ff_device_addr4' />) is set, then the client
      MUST ignore both ffds_user and ffds_group.
    </t>

    <t>
      ffds_efficiency describes the metadata server's evaluation
      as to the effectiveness of each mirror. Note that this is per
      layout and not per device as the metric may change due to
      perceived load, availability to the metadata server, etc.
      Higher values denote higher perceived utility. The way the
      client can select the best mirror to access is discussed in
      <xref target="ss:select_mirror" />.
    </t>
  </section>

  <section title="Interactions Between Devices and Layouts" anchor="layout:inter">
    <t>
      In <xref target='RFC5661' />, the File Layout Type is defined
      such that the relationship between multipathing and filehandles
      can result in either 0, 1, or N filehandles (see Section
      13.3).  Some rationals for this are clustered servers which
      share the same filehandle or allowing for multiple read-only
      copies of the file on the same storage device.  In the Flexible
      File Layout Type, while there is an array of filehandles,
      they are independent of the multipathing being used.  If the
      metadata server wants to provide multiple read-only copies
      of the same file on the same storage device, then it should
      provide multiple ff_device_addr4, each as a mirror.  The
      client can then determine that since the ffds_fh_vers are
      different, then there are multiple copies of the file available.
    </t>
  </section>

  <section title="Handling Version Errors" anchor="layout:versioning">
    <t>
      When the metadata server provides the ffda_versions array in
      the ff_device_addr4 (see <xref target='ff_device_addr4' />),
      the client is able to determine if it can not access a storage
      device with any of the supplied ffdv_version and ffdv_minorversion
      combinations. However, due to the limitations of reporting
      errors in GETDEVICEINFO (see Section 18.40 in
      <xref target='RFC5661' />, the client is not able to specify
      which specific device it can not communicate with over one
      of the provided ffdv_version and ffdv_minorversion combinations.
      Using ff_ioerr4 (see <xref target='ff_ioerr4' /> inside either
      the LAYOUTRETURN (see Section 18.44 of <xref target='RFC5661' />)
      or the LAYOUTERROR (see Section 15.6 of <xref target='NFSv42' />
      and <xref target='sec:layouterror' /> of this document), the
      client can isolate the problematic storage device.
    </t>

    <t>
      The error code to return for LAYOUTRETURN and/or LAYOUTERROR
      is NFS4ERR_MINOR_VERS_MISMATCH. It does not matter whether
      the mismatch is a major version (e.g., client can use NFSv3 but not NFSv4)
      or minor version (e.g., client can use NFSv4.1 but not NFSv4.2),
      the error indicates that for all the supplied combinations for
      ffdv_version and ffdv_minorversion, the client can not communicate
      with the storage device. The client can retry the GETDEVICEINFO
      to see if the metadata server can provide a different
      combination or it can fall back to doing the I/O through the
      metadata server.
    </t>
  </section>
</section>
