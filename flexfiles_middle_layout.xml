<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible File Layout Type" anchor="sec:flexLayout">
  <t>
    The layout4 type is defined in <xref target="RFC5662" /> as follows:
  </t>

  <figure>
    <artwork>
    enum layouttype4 {
        LAYOUT4_NFSV4_1_FILES   = 1,
        LAYOUT4_OSD2_OBJECTS    = 2,
        LAYOUT4_BLOCK_VOLUME    = 3,
        LAYOUT4_FLEX_FILES      = 4
[[RFC Editor: please modify the LAYOUT4_FLEX_FILES
  to be the layouttype assigned by IANA]]
    };
   
    struct layout_content4 {
        layouttype4             loc_type;
        opaque                  loc_body&lt;&gt;;
    };
   
    struct layout4 {
        offset4                 lo_offset;
        length4                 lo_length;
        layoutiomode4           lo_iomode;
        layout_content4         lo_content;
    };
    </artwork>
  </figure>

  <t>
    This document defines structure associated with the layouttype4
    value LAYOUT4_FLEX_FILES.  <xref target="RFC5661" /> specifies
    the loc_body structure as an XDR type "opaque".  The opaque
    layout is uninterpreted by the generic pNFS client layers, but
    obviously must be interpreted by the Flexible File Layout Type
    implementation.  This section defines the structure of this
    opaque value, ff_layout4.
  </t>

  <section title="ff_layout4" anchor="ff_layout4">
    <figure>
      <artwork>
/// struct ff_mirror4 {
///     deviceid4               ffm_deviceid;
///     nfs_fh4                 ffm_fhandle;
///     stateid4                ffm_stateid;
///     opaque_auth             ffm_auth;
/// };
///
      </artwork>
    </figure>

    <figure>
      <artwork>
/// struct ff_layout4 {
///     ff_mirror4              ffl_mirrors&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
      The ff_layout4 structure specifies a layout over a set of
      mirrored copies of the data file.  This mirroring protects
      against loss of data files.
    </t>

    <t>
      It is possible that the file is concatenated from more than
      one layout segment.  Each layout segment MAY represent different
      striping parameters, applying respectively only to the layout
      segment byte range.
    </t>

    <t>
      The ffl_mirrors field represents an array of state information
      for each mirrored copy of the file. Each element is described
      by a ff_mirror type.
    </t>

    <t>
      ffm_deviceid provides the deviceid of the storage device
      holding the data file.
    </t>

    <t>
      ffm_fhandle provides the filehandle of the data file on the
      given storage device. For tight coupling, ffm_stateid provides
      the stateid to be used by the client to access the file. For
      loose coupling and a NFSv4 storage device, the client may use
      an anonymous stateid to perform I/O on the storage device as
      there is no use for the metadata server stateid (no control
      protocol). In such a scenario, the server MUST set the
      ffm_stateid to be zero.
    </t>

    <t>
      For NFSv3 storage devices, ffm_auth provides the RPC credentials
      to be used by the client to access the data files.  For NFSv4.x
      storage devices, the server SHOULD use the AUTH_NONE flavor
      and a zero length opaque body to minimize the returned structure
      length.  The client MUST ignore ffm_auth in this case.

      <cref anchor='AI6 ' source='TH'>
        Even for tightly coupled systems, that cannot be correct!
      </cref>
    </t>
  </section>
</section>
