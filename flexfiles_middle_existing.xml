<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Recovering from Client I/O Errors">
 <t>
The pNFS client may encounter errors when directly accessing
the Data Servers.
However, it is the responsibility of the Metadata Server to
recover from the I/O errors.
When the LAYOUT4_FLEX_FILES layout type is used, the client
MUST report the I/O errors to the server at LAYOUTRETURN time
using the pflr_ioerr4 structure (see <xref target="pflr_errno" />).
 </t>
 <t>
The metadata server analyzes the error and determines the required
recovery operations such as repairing any parity inconsistencies,
recovering media failures, or reconstructing missing objects.
 </t>
 <t>
The metadata server SHOULD recall any outstanding layouts to allow it
exclusive write access to the stripes being recovered and to prevent other
clients from hitting the same error condition.
In these cases, the server MUST complete recovery before handing out
any new layouts to the affected byte ranges.
 </t>
 <t>
Although it MAY be acceptable for the client to propagate a
corresponding error to the application that initiated the I/O operation
and drop any unwritten data, the client SHOULD attempt to retry the original
I/O operation by requesting a new layout using LAYOUTGET and retry the
I/O operation(s) using the new layout, or the client MAY just retry the
I/O operation(s) using regular NFS READ or WRITE operations via the metadata
server.  The client SHOULD attempt to retrieve a new layout and retry the I/O
operation using the Data Server first and only if the error persists, retry
the I/O operation via the metadata server.
 </t>
</section>

<section title="Flexible Files Layout Return">
 <t>
layoutreturn_file4 is used in the LAYOUTRETURN operation
to convey layout-type specific information to the server.
It is defined in the
<xref target="RFC5661" /> as follows:
 </t>

 <figure>
  <artwork>
struct layoutreturn_file4 {
        offset4         lrf_offset;
        length4         lrf_length;
        stateid4        lrf_stateid;
        /* layouttype4 specific data */
        opaque          lrf_body&lt;&gt;;
};

union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
        case LAYOUTRETURN4_FILE:
                layoutreturn_file4      lr_layout;
        default:
                void;
};

struct LAYOUTRETURN4args {
        /* CURRENT_FH: file */
        bool                    lora_reclaim;
        layoutreturn_stateid    lora_recallstateid;
        layouttype4             lora_layout_type;
        layoutiomode4           lora_iomode;
        layoutreturn4           lora_layoutreturn;
};

  </artwork>
 </figure>

 <t>
If the lora_layout_type layout type is LAYOUT4_FLEX_FILES, then
the lrf_body opaque value is defined by the pnfs_ff_layoutreturn4 type.
 </t>
 <t>
The pnfs_ff_layoutreturn4 type allows the client to report I/O error information
or layout usage statistics back to the metadata server as defined below.
 </t>

 <section anchor="pflr_errno" title="pflr_errno">
  <figure>
   <artwork>
/// enum pflr_errno {
///     PNFS_FF_ERR_EIO            = 1,
///     PNFS_FF_ERR_NOT_FOUND      = 2,
///     PNFS_FF_ERR_NO_SPACE       = 3,
///     PNFS_FF_ERR_BAD_STATEID    = 4,
///     PNFS_FF_ERR_NO_ACCESS      = 5,
///     PNFS_FF_ERR_UNREACHABLE    = 6,
///     PNFS_FF_ERR_RESOURCE       = 7
/// };
///
   </artwork>
  </figure>

  <t>
pflr_errno4 is used to represent error types when read/write errors
are reported to the metadata server.
The error codes serve as hints to the metadata server that may help it
in diagnosing the exact reason for the error and in repairing it.

  <list style="symbols">
   <t>
PNFS_FF_ERR_EIO indicates the operation failed because the
Data Server experienced a failure trying to access the object.
The most common source of these errors is media errors,
but other internal errors might cause this as well.
In this case, the metadata server should go examine the broken object
more closely; hence, it should be used as the default error code.
   </t>
   <t>
PNFS_FF_ERR_NOT_FOUND indicates the object ID specifies a Component Object that
does not exist on the Data Server.
   </t>
   <t>
PNFS_FF_ERR_NO_SPACE indicates the operation failed because the
Data Server ran out of free capacity during the operation.
   </t>
   <t>
PNFS_FF_ERR_BAD_STATEID indicates the stateid is not valid.
   </t>
   <t>
PNFS_FF_ERR_NO_ACCESS indicates the RPC credentials do not allow
the requested operation.  This may happen when the client is fenced
off.
The client will need to return the layout and get a new one with fresh credentials.
   </t>
   <t>
PNFS_FF_ERR_UNREACHABLE indicates the client did not complete
the I/O operation at the Data Server due to a communication failure.
Whether or not the I/O operation was executed by the Data Server is undetermined.
   </t>
   <t>
PNFS_FF_ERR_RESOURCE indicates the client did not issue
the I/O operation due to a local problem on the initiator (i.e., client)
side, e.g., when running out of memory.
The client MUST guarantee that the Data Server WRITE operation was never sent.
   </t>
  </list>
  </t>
 </section>

 <section anchor="pnfs_ff_ioerr" title="pnfs_ff_ioerr">
  <figure>
   <artwork>
/// struct pnfs_ff_ioerr {
///     deviceid4           ioe_deviceid;
///     nfs_fh4             ioe_fhandle;
///     offset4             ioe_comp_offset;
///     length4             ioe_comp_length;
///     bool                ioe_iswrite;
///     pnfs_ff_errno       ioe_errno;
/// };
///
   </artwork>
  </figure>
  <t>
The pnfs_ff_ioerr4 structure is used to return error indications
for Component Objects that generated errors during data transfers.
These are hints to the
metadata server that there are problems with that object.
For each error, "ioe_deviceid", "ioe_fhandle", "ioe_comp_offset", and "ioe_comp_length"
represent the Component Object and byte range within the object in which the error occurred;
"ioe_iswrite" is set to "true" if the failed Data Server operation was data modifying, and
"ioe_errno" represents the type of error.
  </t>
  <t>
Component byte ranges in the optional pnfs_ff_ioerr4 structure are
used for recovering the object and MUST be set by the client to cover all
failed I/O operations to the component.
  </t>
 </section>

 <section anchor="pnfs_ff_iostats" title="pnfs_ff_iostats">
  <figure>
   <artwork>
/// struct pnfs_ff_iostats {
///     offset4             ios_offset;
///     length4             ios_length;
///     uint32_t            ios_duration;
///     uint32_t            ios_rd_count;
///     uint64_t            ios_rd_bytes;
///     uint32_t            ios_wr_count;
///     uint64_t            ios_wr_bytes;
/// };
///
   </artwork>
  </figure>

  <t>
With pNFS, the data transfers are performed directly between the pNFS client
and the data servers.  Therefore, the metadata server has no visibility
to the I/O stream and cannot use any statistical information about client I/O
to optimize data storage location.
pnfs_ff_iostats4 MAY be used by the client to report I/O statistics back to
the metadata server upon returning the layout.
Since it is infeasible for the client to report every I/O that used the layout,
the client MAY identify "hot" byte ranges for which to report I/O statistics.
The definition and/or configuration mechanism of what is considered "hot" and
the size of the reported byte range is out of the scope of this document.
It is suggested for client implementation to provide reasonable default
values and an optional run-time management interface to control these
parameters.
For example, a client can define the default byte range resolution to be 1 MB
in size and the thresholds for reporting to be 1 MB/second or 10 I/O
operations per second.
For each byte range, ios_offset and ios_length represent the
starting offset of the range and the range length in bytes.
ios_duration represents the number of seconds the reported burst of I/O
lasted.
ios_rd_count, ios_rd_bytes, ios_wr_count, and ios_wr_bytes represent,
respectively, the number of contiguous read and write I/Os and the respective
aggregate number of bytes transferred within the reported byte range.
  </t>
 </section>

 <section anchor="pnfs_ff_layoutreturn" title="pnfs_ff_layoutreturn">
  <figure>
   <artwork>
/// struct pnfs_ff_layoutreturn {
///     pnfs_ff_ioerr               pflr_ioerr_report&lt;&gt;;
///     pnfs_ff_iostats             pflr_iostats_report&lt;&gt;;
/// };
///
   </artwork>
  </figure>

  <t>
When object I/O operations failed, "pflr_ioerr_report&lt;&gt;" is used to report these errors
to the metadata server as an array of elements of type pnfs_ff_ioerr4.
Each element in the array represents an error that occurred on
the Component Object identified by &lt;ioe_deviceid, ioe_fhandle&gt;.
If no errors are to be reported, the size of the pflr_ioerr_report&lt;&gt; array
is set to zero.
The client MAY also use "pflr_iostats_report&lt;&gt;"
to report a list of I/O statistics as an array of elements
of type pnfs_ff_iostats4.
Each element in the array represents statistics for a particular byte range.
Byte ranges are not guaranteed to be disjoint and MAY repeat or intersect.
  </t>

 </section>
</section>

<section title="Flexible Files Creation Layout Hint">
 <t>
The layouthint4 type is defined in the
<xref target="RFC5661" /> as follows:
 </t>

 <figure>
  <artwork>
struct layouthint4 {
    layouttype4           loh_type;
    opaque                loh_body&lt;&gt;;
};
  </artwork>
 </figure>

 <t>
The layouthint4 structure is used by the client to pass a
hint about the type of layout it would like created for a particular
file.
If the loh_type layout type is LAYOUT4_FLEX_FILES, then
the loh_body opaque value is defined by the pnfs_ff_layouthint type.
 </t>

 <section anchor="pnfs_ff_layouthint" title="pnfs_ff_layouthint">

  <figure>
   <artwork>
/// union pnfs_ff_max_comps_hint switch (bool pfmx_valid) {
///     case TRUE:
///         uint32_t            omx_max_comps;
///     case FALSE:
///         void;
/// };
///
/// union pnfs_ff_stripe_unit_hint switch (bool pfsu_valid) {
///     case TRUE:
///         length4             osu_stripe_unit;
///     case FALSE:
///         void;
/// };
///
/// union pnfs_ff_mirror_cnt_hint switch (bool pfmc_valid) {
///     case TRUE:
///         uint32_t            omc_mirror_cnt;
///     case FALSE:
///         void;
/// };
///
/// union pnfs_ff_striping_pattern_hint switch (bool pfsp_valid) {
///     case TRUE:
///         pnfs_ff_striping_pattern    pfsp_striping_pattern;
///     case FALSE:
///         void;
/// };
///
/// struct pnfs_ff_layouthint {
///     pnfs_ff_max_comps_hint         pflh_max_comps_hint;
///     pnfs_ff_stripe_unit_hint       pflh_stripe_unit_hint;
///     pnfs_ff_mirror_cnt_hint        pflh_mirror_cnt_hint;
///     pnfs_ff_striping_pattern_hint  pflh_striping_pattern_hint;
/// };
///
   </artwork>
  </figure>

  <t>
This type conveys hints for the desired data map.
All parameters are optional so the client can give values for only
the parameters it cares about, e.g. it can provide a hint for the desired
number of mirrored components, regardless of the striping pattern selected
for the file.  The server should make an attempt to honor the hints,
but it can ignore any or all of them at its own discretion and
without failing the respective CREATE operation.
  </t>
 </section>
</section>

<section title="Recalling Layouts">
 <t>
The Flexible Files metadata server should recall outstanding layouts
in the following cases:

 <list style='symbols'>
  <t>
When the file's security policy changes, i.e.,
Access Control Lists (ACLs) or permission mode bits
are set.
  </t>
  <t>
  When the file's layout changes, rendering outstanding layouts invalid.
  </t>
  <t>
When there are sharing conflicts. For example, the server will issue
stripe-aligned layout segments for RAID-5 objects.  To prevent corruption
of the file's parity, multiple clients must not hold valid write layouts
for the same stripes.
An outstanding READ/WRITE (RW) layout should be recalled when a conflicting LAYOUTGET
is received from a different client for LAYOUTIOMODE4_RW and for a byte range
overlapping with the outstanding layout segment.
  </t>
 </list>
 </t>

 <section title="CB_RECALL_ANY" anchor="CB_RECALL_ANY">
  <t>
The metadata server can use the CB_RECALL_ANY callback operation to notify
the client to return some or all of its layouts.
The <xref target="RFC5661" /> defines
the following types:
  </t>

  <figure>
   <artwork>
const RCA4_TYPE_MASK_FF_LAYOUT_MIN     = -2;
const RCA4_TYPE_MASK_FF_LAYOUT_MAX     = -1;
[[RFC Editor: please insert assigned constants]]

struct  CB_RECALL_ANY4args      {
    uint32_t        craa_objects_to_keep;
    bitmap4         craa_type_mask;
};
   </artwork>
  </figure>

  <t>
Typically, CB_RECALL_ANY will be used to recall client state when the server
needs to reclaim resources. The craa_type_mask bitmap specifies the type of
resources that are recalled and the craa_objects_to_keep value specifies
how many of the recalled objects the client is allowed to keep.

The Flexible Files layout type mask flags are defined as follows.
They represent the iomode of the recalled layouts.
In response, the client SHOULD return layouts of the recalled iomode
that it needs the least,
keeping at most craa_objects_to_keep object-based layouts.
  </t>
  <figure>
   <artwork>
/// enum pnfs_ff_cb_recall_any_mask {
///     PNFS_FF_RCA4_TYPE_MASK_READ = -2,
///     PNFS_FF_RCA4_TYPE_MASK_RW   = -1
[[RFC Editor: please insert assigned constants]]
/// };
///
   </artwork>
  </figure>

  <t>
The PNFS_FF_RCA4_TYPE_MASK_READ flag notifies the client to return layouts
of iomode LAYOUTIOMODE4_READ.
Similarly, the PNFS_FF_RCA4_TYPE_MASK_RW flag notifies the client to return layouts
of iomode LAYOUTIOMODE4_RW.
When both mask flags are set, the client is notified to return layouts
of either iomode.
  </t>
  </section>
</section>
