<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible Files Layout" anchor="sec:flexLayout">

       <t>
       The layout4 type is defined in the <xref target="RFC5662" /> as follows:
       </t>
       <figure>
    <artwork>
/// enum layouttype4 {
///     LAYOUT4_NFSV4_1_FILES   = 1,
///     LAYOUT4_OSD2_OBJECTS    = 2,
///     LAYOUT4_BLOCK_VOLUME    = 3,
///     LAYOUT4_FLEX_FILES      = 4
[[RFC Editor: please insert layouttype assigned by IANA]]
/// };
///
/// struct layout_content4 {
///     layouttype4             loc_type;
///     opaque                  loc_body&lt;&gt;;
/// };
///
/// struct layout4 {
///     offset4                 lo_offset;
///     length4                 lo_length;
///     layoutiomode4           lo_iomode;
///     layout_content4         lo_content;
/// };
    </artwork>
       </figure>

       <t>
       This document defines structure associated with the layouttype4 value
       LAYOUT4_FLEX_FILES.
       NFSv4.1 <xref target="RFC5661" />
       specifies the loc_body structure as an XDR type "opaque".
       The opaque layout is uninterpreted by the generic pNFS client layers,
       but obviously must be interpreted by the flexible files layout driver.
       This section defines the structure of this opaque value, pnfs_ff_layout4.
       </t>

       <section title="pnfs_ff_layout" anchor="pnfs_ff_layout">
    <figure>
      <artwork>
/// enum pnfs_ff_striping_pattern {
///     PFSP_SPARSE_STRIPING = 1,
///     PFSP_DENSE_STRIPING  = 2,
///     PFSP_RAID_4          = 4,
///     PFSP_RAID_5          = 5,
///     PFSP_RAID_PQ         = 6
/// };
///
/// enum pnfs_ff_comp_type {
///     PNFS_FF_COMP_MISSING = 0,
///     PNFS_FF_COMP_PACKED  = 1,
///     PNFS_FF_COMP_FULL    = 2
/// };
///
/// struct pnfs_ff_comp_full {
///     deviceid4               pfcf_deviceid;
///     nfs_fh4                 pfcf_fhandle;
///     stateid4                pfcf_stateid;
///     opaque_auth             pfcf_auth;
///     uint32_t                pfcf_metric;
/// };
///
/// union pnfs_ff_comp switch (pnfs_ff_comp_type pfc_type) {
///    case PNFS_FF_COMP_MISSING:
///         void;
///
///    case PNFS_FF_COMP_PACKED:
///         deviceid4               pfcp_deviceid;
///
///    case PNFS_FF_COMP_FULL:
///         pnfs_ff_comp_full       pfcp_full;
/// };
///
/// struct pnfs_ff_layout {
///     pnfs_ff_striping_pattern    pfl_striping_pattern;
///     uint32_t                    pfl_num_comps;
///     uint32_t                    pfl_mirror_cnt;
///     length4                     pfl_stripe_unit;
///     nfs_fh4                     pfl_global_fh;
///     uint32_t                    pfl_comps_index;
///     pnfs_ff_comp                pfl_comps&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
    The pnfs_ff_layout structure specifies a layout over a set of Component Objects.
    The layout parameterizes the algorithm that maps the file's contents
    within the returned byte range,
    as represented by lo_offset and lo_length, over the Component Objects.
    </t>

    <t>
    It is possible that the file is concatenated from more than one layout
    segment.
    Each layout segment MAY represent different striping parameters,
    applying respectively only to the layout segment byte range.
    </t>

    <t>
    This section provides a brief introduction to the layout parameters.
    See <xref target="sec:stripingTopologies"/>
    for a more detailed description of the different striping
    schemes and the respective interpretation of the layout parameters
    for each striping scheme.
    </t>

    <t>
    In addition to mapping data using simple striping schemes where loss of a single
    component object results in data loss, the layout parameters support
    mirroring and more advanced redundancy schemes that protect against loss of
    component objects.
    pfl_striping_pattern represents the algorithm to be used for mapping
    byte offsets in the file address space to corresponding component objects
    in the returned layout and byte offsets in the component's address space.
    pfl_striping_pattern also represents methods for storing and retrieving
    redundant data that can be used to recover from failure or loss of component objects.
    </t>

    <t>
    pfl_num_comps is the total number of component objects the file is
    striped over within the returned byte range,
    not counting mirrored components (See pfl_mirror_cnt below).
    Note that the server MAY grow the file by adding more components to the stripe
    while clients hold valid layouts until the file has reached its final stripe width.
    </t>

    <t>
    pfl_mirror_cnt represents the number of mirrors each component
    in the stripe has.
    If there is no mirroring then pfm_mirror_cnt MUST be 0.
    Otherwise, the number of entries listed in pfl_comps MUST be a
    multiple of (pfl_mirror_cnt+1).
    </t>

    <t>
    pfl_stripe_unit is the number of bytes placed on one component
    before advancing to the next one in the list of components.
    When the file is striped over a single component object
    (pfl_num_comps equals to 1), the stripe unit has no use and the server
    SHOULD set it to the server default value or to zero;
    otherwise, pfl_stripe_unit MUST NOT be set to zero.
    </t>

    <t>
    The pfl_comps field represents an array of component objects.
    The data placement algorithm that maps file data onto component objects
    assumes that each component object occurs exactly once in the array of components.
    Therefore, component objects MUST appear in the pfl_comps array only once.
    The components array may represent all objects comprising the file,
    in which case pfl_comps_index is set to zero and the number of entries
    in the pfl_comps array is equal to pfl_num_comps * (pfl_mirror_cnt + 1).
    The server MAY return fewer components than pfl_num_comps,
    provided that the returned byte range represented by lo_offset and lo_count maps
    in whole into the set of returned component objects.
    In this case, pfl_comps_index represents the logical position of the returned
    components array, pfl_comps, within the full array of components
    that comprise the file.
    pfl_comps_index MUST be a multiple of (pfl_mirror_cnt + 1).
    </t>

    <t>
    Each component object in the pfl_comps array is described by the
    pnfs_ff_comp type.
    </t>

    <t>
    When a component object is unavailable pfc_type is set to PNFS_FF_COMP_MISSING and no other
    information for this component is returned.
    When a data redundancy scheme is being used, as represented by pfl_striping_pattern,
    the client MAY use a respective data recovery algorithm to reconstruct
    data that is logically stored on the missing component using user data
    and redundant data stored on the available components in the containing
    stripe.
    </t>

    <t>
    The server MUST set the same pfc_type for all available components to
    either PNFS_FF_COMP_PACKED or PNFS_FF_COMP_FULL.
    </t>

    <t>
    When NFSv4.1 Clustered Data Servers are used, the metadata server implements
    the global state model where all data servers share the same stateid
    and filehandle for the file.
    In such case, the client MUST use the open, delegation, or lock stateid
    returned by the metadata server for the file for accessing the Data
    Servers for READ and WRITE; the global filehandle to
    be used by the client is provided by pfl_global_fh.
    If the metadata server filehandle for the file is being used by all data servers
    then pfl_global_fh MAY be set to an empty filehandle.
    </t>

    <t>
    pfcp_deviceid or pfcf_deviceid provide the
    deviceid of the data server holding the Component Object.
    </t>

    <t>
    When standalone data servers are used, either over NFSv4 or NFSv4.1,
    pfl_global_fh SHOULD be set to an empty filehandle and it MUST be ignored
    by the client and
    pfcf_fhandle provides the filehandle of the Data Server file
    holding the Component Object, and pfcf_stateid provides the stateid to
    be used by the client to access the file.
    </t>

    <t>
    For NFSv3 Data Servers, pfcf_auth provides the RPC credentials
    to be used by the client to access the Component Objects.
    For NFSv4.x Data Servers, the server SHOULD use the AUTH_NONE
    flavor and a zero length opaque body to minimize the returned
    structure length.  The client MUST ignore pfxf_auth in this case.
    </t>

    <t>
    When pfl_mirror_cnt is not zero pfcf_metric indicates the distance
    to the client the distance of the respective component object,
    otherwise the server MUST set pfcf_metric to zero.
    When reading data, the client the client is advised to read from
    components with the lowest pfcf_metric.
    When there are several components with the same pfcf_metric
    client implementations may implement a load distribution algorithm
    to evenly distribute the read load across several devices and
    by so provide larger bandwidth.
    </t>
  </section>

  <section title="Striping Topologies" anchor="sec:stripingTopologies">

    <t>
    This section describes the different data mapping schemes in detail.
    </t>

    <t>
    pnfs_ff_striping_pattern determines the algorithm and placement of
    redundant data.
    This section defines the different redundancy algorithms.
    Note: The term "RAID" (Redundant Array of Independent
    Disks) is used in this document to represent an array of Component
    Objects that store data for an individual User File.
    The objects are stored on independent Data Servers.
    User File data is encoded and striped across the array of Component
    Objects using algorithms developed for block-based RAID systems.
    </t>

    <section anchor="sec:sparseStriping" title="PFSP_SPARSE_STRIPING">
    <t>
    The mapping from the logical
    offset within a file (L) to the Component Object C and
    object-specific offset O is direct and straight forward
    as defined by the following equations:
    </t>

    <figure>
      <artwork>
L: logical offset into the file

W: stripe width
    W = pfl_num_comps

S: number of bytes in a stripe
    S = W * pfl_stripe_unit

N: stripe number
    N = L / S

C: component index corresponding to L
   C = (L % S) / pfl_stripe_unit

O: The component offset corresponding to L
   O = L
      </artwork>
    </figure>

    <t>
    Note that this computation does not accommodate the same
    object appearing in the pfl_comps array multiple times.
    Therefore the server may not return layouts with the same object appearing
    multiple times. If needed the server can return multiple layout segments each
    covering a single instance of the object.
    </t>

    <t>
    PFSP_SPARSE_STRIPING means there is no
    parity data, so all bytes in the component objects are
    data bytes located by the above equations for C and O.
    If a component object is marked as PNFS_FF_COMP_MISSING,
    the pNFS client MUST either return an I/O error if this component
    is attempted to be read or, alternatively, it can
    retry the READ against the pNFS server.
    </t>
    </section>

    <section anchor="sec:denseStriping" title="PFSP_DENSE_STRIPING">
    <t>
    The mapping from the logical
    offset within a file (L) to the component object C and
    object-specific offset O is defined by the following equations:
    </t>

    <figure>
      <artwork>
L: logical offset into the file

W: stripe width
    W = pfl_num_comps

S: number of bytes in a stripe
    S = W * pfl_stripe_unit

N: stripe number
    N = L / S

C: component index corresponding to L
   C = (L % S) / pfl_stripe_unit

O: The component offset corresponding to L
   O = (N * pfl_stripe_unit) + (L % pfl_stripe_unit)
      </artwork>
    </figure>

    <t>
    Note that this computation does not accommodate the same
    object appearing in the pfl_comps array multiple times.
    Therefore the server may not return layouts with the same object appearing
    multiple times. If needed the server can return multiple layout segments each
    covering a single instance of the object.
    </t>

    <t>
    PFSP_DENSE_STRIPING means there is no
    parity data, so all bytes in the component objects are
    data bytes located by the above equations for C and O.
    If a component object is marked as PNFS_FF_COMP_MISSING,
    the pNFS client MUST either return an I/O error if this component
    is attempted to be read or, alternatively, it can
    retry the READ against the pNFS server.
    </t>

    <t>
    Note that the layout depends on the file size, which the client
    learns from the generic return parameters of LAYOUTGET,
    by doing GETATTR commands to the Metadata Server.
    The client uses the file size to decide if it should fill holes
    with zeros or return a short read.
    Striping patterns can cause cases where Component Objects are
    shorter than other components because a hole happens to correspond to
    the last part of the Component Object.
    </t>
    </section>

    <section anchor="PFSP_RAID_4" title="PFSP_RAID_4">
    <t>
    PFSP_RAID_4 means that the last component object in the stripe
    contains parity information computed over the rest of
    the stripe with an XOR operation.
    If a Component Object is unavailable, the client can
    read the rest of the stripe units in the damaged stripe
    and recompute the missing stripe unit by XORing the other
    stripe units in the stripe.  Or the client can replay
    the READ against the pNFS server that will presumably
    perform the reconstructed read on the client's behalf.
    </t>

    <t>
    When parity is present in the file,
    then the number of parity devices is taken into account in the above equations
    when calculating (D), the number of data devices in a stripe, as follows:
    </t>

    <figure>
      <artwork>
P: number of parity devices in each stripe
   P = 1

D: number of data devices in a stripe
   D = W - P

I: parity device index
   I = D
      </artwork>
    </figure>
    </section>

    <section anchor="PFSP_RAID_5" title="PFSP_RAID_5">
    <t>
    PNFS_OBJ_RAID_5 means that the position of the parity data
    is rotated on each stripe.
    In the first stripe, the last component holds the parity.
    In the second stripe, the next-to-last component holds the parity,
    and so on.
    In this scheme, all stripe units are rotated so that I/O
    is evenly spread across objects as the file is read
    sequentially.
    The rotated parity layout is illustrated here,
    with hexadecimal numbers indicating the stripe unit.
    </t>

    <figure>
      <artwork>
0 1 2 P
4 5 P 3
8 P 6 7
P 9 a b
      </artwork>
    </figure>

    <t>
    Note that the math for RAID_5 is similar to RAID_4 only that the device indices
    for each stripe are rotated backwards.
    So start with the equations above for RAID_4, then compute the rotation as
    described below.
    </t>

    <figure>
      <artwork>
P: number of parity devices in each stripe
   P = 1

PC: Parity Cycle
    PC = W

R: The parity rotation index
   (N is as computed in above equations for RAID-4)
   R = N % PC

I: parity device index
   I = (W + W - (R + 1) * P) % W

Cr: The rotated device index
    (C is as computed in the above equations for RAID-4)
    Cr = (W + C - (R * P)) % W

Note: W is added above to avoid negative numbers modulo math.
      </artwork>
    </figure>
    </section> <!-- PFSP_RAID_5 -->

    <section anchor="PFSP_RAID_PQ" title="PFSP_RAID_PQ">
    <t>
    PFSP_RAID_PQ is a double-parity scheme that uses
    the Reed-Solomon P+Q encoding scheme <xref target='ErrorCorrectingCodes' />.
    In this layout, the last two component objects hold the P and Q data, respectively.
    P is parity computed with XOR.
    The Q computation is described in detail by
    Anvin <xref target='MathOfRAID-6' />. The same polynomial
    "x^8+x^4+x^3+x^2+1" and Galois field size of 2^8 are used here.
    Clients may simply choose to read data through the metadata server if
    two or more components are missing or damaged.
    </t>

    <t>
    The equations given above for embedded parity can be
    used to map a file offset to the correct component
    object by setting the number of parity components (P) to 2
    instead of 1 for RAID-5 and computing the Parity Cycle length
    as the Lowest Common Multiple
    of pfl_num_comps and P, divided by P, as described below.
    Note: This algorithm can be used also for RAID-5 where P=1.
    </t>

    <figure>
      <artwork>
P: number of parity devices
   P = 2

PC: Parity cycle:
    PC = LCM(W, P) / P

Q: The device index holding the Q component
   (I is as computed in the above equations for RAID-5)
   Qdev = (I + 1) % W
      </artwork>
    </figure>
    </section> <!-- PFSP_RAID_PQ -->

    <section title="RAID Usage and Implementation Notes">
    <t>
    RAID layouts with redundant data in their stripes
    require additional serialization of updates to
    ensure correct operation. Otherwise, if two clients simultaneously
    write to the same logical range of an object, the result could include
    different data in the same ranges of mirrored tuples, or corrupt parity
    information.
    It is the responsibility of the metadata server to enforce serialization
    requirements such as this. For example, the metadata server may do
    so by not granting overlapping write layouts within mirrored objects.
    </t>

    <t>
    Many alternative encoding schemes exist for P >= 2
    <xref target='ErasureCodingLibraries' />.
    These involve P or Q equations different than those used in PFSP_RAID_PQ.
    Thus, if one of these schemes is to be used in the future, a distinct value
    must be added to pnfs_ff_striping_pattern for it. While Reed-Solomon codes
    are well understood, recently discovered schemes such as Liberation
    codes are more computationally efficient for small group_widths, and
    Cauchy Reed-Solomon codes are more computationally efficient for higher
    values of P.
    </t>
    </section>
  </section>

  <section anchor="Mirroring" title="Mirroring">
  <t>
  The pfl_mirror_cnt is used to replicate a file by replicating its Component Objects.
  If there is no mirroring, then pfs_mirror_cnt MUST be 0.
  If pfl_mirror_cnt is greater than zero, then the size of the pfl_comps
  array MUST be a multiple of (pfl_mirror_cnt + 1).
  Thus, for a classic mirror on two objects, pfl_mirror_cnt is one.
  Note that mirroring can be defined over any striping pattern.
  </t>

  <t>
  Replicas are adjacent in the olo_components array,
  and the value C produced by the above equations is not
  a direct index into the pfl_comps array.
  Instead, the following equations determine the replica component index RCi,
  where i ranges from 0 to pfl_mirror_cnt.
  </t>

  <figure>
    <artwork>
FW = size of pfl_comps array / (pfl_mirror_cnt+1)

C = component index for striping or two-level striping
    as calculated using above equations

i ranges from 0 to pfl_mirror_cnt, inclusive
RCi = C * (pfl_mirror_cnt+1) + i
    </artwork>
  </figure>
  </section>
</section>

<section title="Recovering from Client I/O Errors">
 <t>
The pNFS client may encounter errors when directly accessing
the Data Servers.
However, it is the responsibility of the Metadata Server to
recover from the I/O errors.
When the LAYOUT4_FLEX_FILES layout type is used, the client
MUST report the I/O errors to the server at LAYOUTRETURN time
using the pflr_ioerr4 structure (see <xref target="pflr_errno" />).
 </t>
 <t>
The metadata server analyzes the error and determines the required
recovery operations such as repairing any parity inconsistencies,
recovering media failures, or reconstructing missing objects.
 </t>
 <t>
The metadata server SHOULD recall any outstanding layouts to allow it
exclusive write access to the stripes being recovered and to prevent other
clients from hitting the same error condition.
In these cases, the server MUST complete recovery before handing out
any new layouts to the affected byte ranges.
 </t>
 <t>
Although it MAY be acceptable for the client to propagate a
corresponding error to the application that initiated the I/O operation
and drop any unwritten data, the client SHOULD attempt to retry the original
I/O operation by requesting a new layout using LAYOUTGET and retry the
I/O operation(s) using the new layout, or the client MAY just retry the
I/O operation(s) using regular NFS READ or WRITE operations via the metadata
server.  The client SHOULD attempt to retrieve a new layout and retry the I/O
operation using the Data Server first and only if the error persists, retry
the I/O operation via the metadata server.
 </t>
</section>

<section title="Flexible Files Layout Return">
 <t>
layoutreturn_file4 is used in the LAYOUTRETURN operation
to convey layout-type specific information to the server.
It is defined in the
<xref target="RFC5661" /> as follows:
 </t>

 <figure>
  <artwork>
struct layoutreturn_file4 {
        offset4         lrf_offset;
        length4         lrf_length;
        stateid4        lrf_stateid;
        /* layouttype4 specific data */
        opaque          lrf_body&lt;&gt;;
};

union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
        case LAYOUTRETURN4_FILE:
                layoutreturn_file4      lr_layout;
        default:
                void;
};

struct LAYOUTRETURN4args {
        /* CURRENT_FH: file */
        bool                    lora_reclaim;
        layoutreturn_stateid    lora_recallstateid;
        layouttype4             lora_layout_type;
        layoutiomode4           lora_iomode;
        layoutreturn4           lora_layoutreturn;
};

  </artwork>
 </figure>

 <t>
If the lora_layout_type layout type is LAYOUT4_FLEX_FILES, then
the lrf_body opaque value is defined by the pnfs_ff_layoutreturn4 type.
 </t>
 <t>
The pnfs_ff_layoutreturn4 type allows the client to report I/O error information
or layout usage statistics back to the metadata server as defined below.
 </t>

 <section anchor="pflr_errno" title="pflr_errno">
  <figure>
   <artwork>
/// enum pflr_errno {
///     PNFS_FF_ERR_EIO            = 1,
///     PNFS_FF_ERR_NOT_FOUND      = 2,
///     PNFS_FF_ERR_NO_SPACE       = 3,
///     PNFS_FF_ERR_BAD_STATEID    = 4,
///     PNFS_FF_ERR_NO_ACCESS      = 5,
///     PNFS_FF_ERR_UNREACHABLE    = 6,
///     PNFS_FF_ERR_RESOURCE       = 7
/// };
///
   </artwork>
  </figure>

  <t>
pflr_errno4 is used to represent error types when read/write errors
are reported to the metadata server.
The error codes serve as hints to the metadata server that may help it
in diagnosing the exact reason for the error and in repairing it.

  <list style="symbols">
   <t>
PNFS_FF_ERR_EIO indicates the operation failed because the
Data Server experienced a failure trying to access the object.
The most common source of these errors is media errors,
but other internal errors might cause this as well.
In this case, the metadata server should go examine the broken object
more closely; hence, it should be used as the default error code.
   </t>
   <t>
PNFS_FF_ERR_NOT_FOUND indicates the object ID specifies a Component Object that
does not exist on the Data Server.
   </t>
   <t>
PNFS_FF_ERR_NO_SPACE indicates the operation failed because the
Data Server ran out of free capacity during the operation.
   </t>
   <t>
PNFS_FF_ERR_BAD_STATEID indicates the stateid is not valid.
   </t>
   <t>
PNFS_FF_ERR_NO_ACCESS indicates the RPC credentials do not allow
the requested operation.  This may happen when the client is fenced
off.
The client will need to return the layout and get a new one with fresh credentials.
   </t>
   <t>
PNFS_FF_ERR_UNREACHABLE indicates the client did not complete
the I/O operation at the Data Server due to a communication failure.
Whether or not the I/O operation was executed by the Data Server is undetermined.
   </t>
   <t>
PNFS_FF_ERR_RESOURCE indicates the client did not issue
the I/O operation due to a local problem on the initiator (i.e., client)
side, e.g., when running out of memory.
The client MUST guarantee that the Data Server WRITE operation was never sent.
   </t>
  </list>
  </t>
 </section>

 <section anchor="pnfs_ff_ioerr" title="pnfs_ff_ioerr">
  <figure>
   <artwork>
/// struct pnfs_ff_ioerr {
///     deviceid4           ioe_deviceid;
///     nfs_fh4             ioe_fhandle;
///     offset4             ioe_comp_offset;
///     length4             ioe_comp_length;
///     bool                ioe_iswrite;
///     pnfs_ff_errno       ioe_errno;
/// };
///
   </artwork>
  </figure>
  <t>
The pnfs_ff_ioerr4 structure is used to return error indications
for Component Objects that generated errors during data transfers.
These are hints to the
metadata server that there are problems with that object.
For each error, "ioe_deviceid", "ioe_fhandle", "ioe_comp_offset", and "ioe_comp_length"
represent the Component Object and byte range within the object in which the error occurred;
"ioe_iswrite" is set to "true" if the failed Data Server operation was data modifying, and
"ioe_errno" represents the type of error.
  </t>
  <t>
Component byte ranges in the optional pnfs_ff_ioerr4 structure are
used for recovering the object and MUST be set by the client to cover all
failed I/O operations to the component.
  </t>
 </section>

 <section anchor="pnfs_ff_iostats" title="pnfs_ff_iostats">
  <figure>
   <artwork>
/// struct pnfs_ff_iostats {
///     offset4             ios_offset;
///     length4             ios_length;
///     uint32_t            ios_duration;
///     uint32_t            ios_rd_count;
///     uint64_t            ios_rd_bytes;
///     uint32_t            ios_wr_count;
///     uint64_t            ios_wr_bytes;
/// };
///
   </artwork>
  </figure>

  <t>
With pNFS, the data transfers are performed directly between the pNFS client
and the data servers.  Therefore, the metadata server has no visibility
to the I/O stream and cannot use any statistical information about client I/O
to optimize data storage location.
pnfs_ff_iostats4 MAY be used by the client to report I/O statistics back to
the metadata server upon returning the layout.
Since it is infeasible for the client to report every I/O that used the layout,
the client MAY identify "hot" byte ranges for which to report I/O statistics.
The definition and/or configuration mechanism of what is considered "hot" and
the size of the reported byte range is out of the scope of this document.
It is suggested for client implementation to provide reasonable default
values and an optional run-time management interface to control these
parameters.
For example, a client can define the default byte range resolution to be 1 MB
in size and the thresholds for reporting to be 1 MB/second or 10 I/O
operations per second.
For each byte range, ios_offset and ios_length represent the
starting offset of the range and the range length in bytes.
ios_duration represents the number of seconds the reported burst of I/O
lasted.
ios_rd_count, ios_rd_bytes, ios_wr_count, and ios_wr_bytes represent,
respectively, the number of contiguous read and write I/Os and the respective
aggregate number of bytes transferred within the reported byte range.
  </t>
 </section>

 <section anchor="pnfs_ff_layoutreturn" title="pnfs_ff_layoutreturn">
  <figure>
   <artwork>
/// struct pnfs_ff_layoutreturn {
///     pnfs_ff_ioerr               pflr_ioerr_report&lt;&gt;;
///     pnfs_ff_iostats             pflr_iostats_report&lt;&gt;;
/// };
///
   </artwork>
  </figure>

  <t>
When object I/O operations failed, "pflr_ioerr_report&lt;&gt;" is used to report these errors
to the metadata server as an array of elements of type pnfs_ff_ioerr4.
Each element in the array represents an error that occurred on
the Component Object identified by &lt;ioe_deviceid, ioe_fhandle&gt;.
If no errors are to be reported, the size of the pflr_ioerr_report&lt;&gt; array
is set to zero.
The client MAY also use "pflr_iostats_report&lt;&gt;"
to report a list of I/O statistics as an array of elements
of type pnfs_ff_iostats4.
Each element in the array represents statistics for a particular byte range.
Byte ranges are not guaranteed to be disjoint and MAY repeat or intersect.
  </t>

 </section>
</section>

<section title="Flexible Files Creation Layout Hint">
 <t>
The layouthint4 type is defined in the
<xref target="RFC5661" /> as follows:
 </t>

 <figure>
  <artwork>
struct layouthint4 {
    layouttype4           loh_type;
    opaque                loh_body&lt;&gt;;
};
  </artwork>
 </figure>

 <t>
The layouthint4 structure is used by the client to pass a
hint about the type of layout it would like created for a particular
file.
If the loh_type layout type is LAYOUT4_FLEX_FILES, then
the loh_body opaque value is defined by the pnfs_ff_layouthint type.
 </t>

 <section anchor="pnfs_ff_layouthint" title="pnfs_ff_layouthint">

  <figure>
   <artwork>
/// union pnfs_ff_max_comps_hint switch (bool pfmx_valid) {
///     case TRUE:
///         uint32_t            omx_max_comps;
///     case FALSE:
///         void;
/// };
///
/// union pnfs_ff_stripe_unit_hint switch (bool pfsu_valid) {
///     case TRUE:
///         length4             osu_stripe_unit;
///     case FALSE:
///         void;
/// };
///
/// union pnfs_ff_mirror_cnt_hint switch (bool pfmc_valid) {
///     case TRUE:
///         uint32_t            omc_mirror_cnt;
///     case FALSE:
///         void;
/// };
///
/// union pnfs_ff_striping_pattern_hint switch (bool pfsp_valid) {
///     case TRUE:
///         pnfs_ff_striping_pattern    pfsp_striping_pattern;
///     case FALSE:
///         void;
/// };
///
/// struct pnfs_ff_layouthint {
///     pnfs_ff_max_comps_hint         pflh_max_comps_hint;
///     pnfs_ff_stripe_unit_hint       pflh_stripe_unit_hint;
///     pnfs_ff_mirror_cnt_hint        pflh_mirror_cnt_hint;
///     pnfs_ff_striping_pattern_hint  pflh_striping_pattern_hint;
/// };
///
   </artwork>
  </figure>

  <t>
This type conveys hints for the desired data map.
All parameters are optional so the client can give values for only
the parameters it cares about, e.g. it can provide a hint for the desired
number of mirrored components, regardless of the striping pattern selected
for the file.  The server should make an attempt to honor the hints,
but it can ignore any or all of them at its own discretion and
without failing the respective CREATE operation.
  </t>
 </section>
</section>

<section title="Recalling Layouts">
 <t>
The Flexible Files metadata server should recall outstanding layouts
in the following cases:

 <list style='symbols'>
  <t>
When the file's security policy changes, i.e.,
Access Control Lists (ACLs) or permission mode bits
are set.
  </t>
  <t>
  When the file's layout changes, rendering outstanding layouts invalid.
  </t>
  <t>
When there are sharing conflicts. For example, the server will issue
stripe-aligned layout segments for RAID-5 objects.  To prevent corruption
of the file's parity, multiple clients must not hold valid write layouts
for the same stripes.
An outstanding READ/WRITE (RW) layout should be recalled when a conflicting LAYOUTGET
is received from a different client for LAYOUTIOMODE4_RW and for a byte range
overlapping with the outstanding layout segment.
  </t>
 </list>
 </t>

 <section title="CB_RECALL_ANY" anchor="CB_RECALL_ANY">
  <t>
The metadata server can use the CB_RECALL_ANY callback operation to notify
the client to return some or all of its layouts.
The <xref target="RFC5661" /> defines
the following types:
  </t>

  <figure>
   <artwork>
const RCA4_TYPE_MASK_FF_LAYOUT_MIN     = -2;
const RCA4_TYPE_MASK_FF_LAYOUT_MAX     = -1;
[[RFC Editor: please insert assigned constants]]

struct  CB_RECALL_ANY4args      {
    uint32_t        craa_objects_to_keep;
    bitmap4         craa_type_mask;
};
   </artwork>
  </figure>

  <t>
Typically, CB_RECALL_ANY will be used to recall client state when the server
needs to reclaim resources. The craa_type_mask bitmap specifies the type of
resources that are recalled and the craa_objects_to_keep value specifies
how many of the recalled objects the client is allowed to keep.

The Flexible Files layout type mask flags are defined as follows.
They represent the iomode of the recalled layouts.
In response, the client SHOULD return layouts of the recalled iomode
that it needs the least,
keeping at most craa_objects_to_keep object-based layouts.
  </t>
  <figure>
   <artwork>
/// enum pnfs_ff_cb_recall_any_mask {
///     PNFS_FF_RCA4_TYPE_MASK_READ = -2,
///     PNFS_FF_RCA4_TYPE_MASK_RW   = -1
[[RFC Editor: please insert assigned constants]]
/// };
///
   </artwork>
  </figure>

  <t>
The PNFS_FF_RCA4_TYPE_MASK_READ flag notifies the client to return layouts
of iomode LAYOUTIOMODE4_READ.
Similarly, the PNFS_FF_RCA4_TYPE_MASK_RW flag notifies the client to return layouts
of iomode LAYOUTIOMODE4_RW.
When both mask flags are set, the client is notified to return layouts
of either iomode.
  </t>
  </section>
</section>
