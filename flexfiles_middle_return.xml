<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible Files Layout Type Return">
  <t>
    layoutreturn_file4 is used in the LAYOUTRETURN operation
    to convey layout-type specific information to the server.
    It is defined in <xref target="RFC5661" /> as follows:
  </t>

  <figure>
    <artwork>
struct layoutreturn_file4 {
        offset4         lrf_offset;
        length4         lrf_length;
        stateid4        lrf_stateid;
        /* layouttype4 specific data */
        opaque          lrf_body&lt;&gt;;
};

    </artwork>
  </figure>

  <figure>
    <artwork>
union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
        case LAYOUTRETURN4_FILE:
                layoutreturn_file4      lr_layout;
        default:
                void;
};

    </artwork>
  </figure>

  <figure>
    <artwork>
struct LAYOUTRETURN4args {
        /* CURRENT_FH: file */
        bool                    lora_reclaim;
        layoutreturn_stateid    lora_recallstateid;
        layouttype4             lora_layout_type;
        layoutiomode4           lora_iomode;
        layoutreturn4           lora_layoutreturn;
};

    </artwork>
  </figure>

  <t>
    If the lora_layout_type layout type is LAYOUT4_FLEX_FILES, then
    the lrf_body opaque value is defined by the ff_layoutreturn4
    type.
  </t>

  <t>
    The ff_layoutreturn4 type allows the client to report I/O
    error information or layout usage statistics back to the metadata
    server as defined below.
  </t>

  <section anchor="ff_errno" title="ff_errno">
    <figure>
      <artwork>
/// enum ff_errno {
///     FF_ERR_EIO            = 1,
///     FF_ERR_NOT_FOUND      = 2,
///     FF_ERR_NO_SPACE       = 3,
///     FF_ERR_BAD_STATEID    = 4,
///     FF_ERR_NO_ACCESS      = 5,
///     FF_ERR_UNREACHABLE    = 6,
///     FF_ERR_RESOURCE       = 7
/// };
///
      </artwork>
    </figure>

    <t>
      ff_errno is used to represent error types when read/write
      errors are reported to the metadata server.  The error codes
      serve as hints to the metadata server that may help it in
      diagnosing the exact reason for the error and in repairing it.

      <list style="hanging">
        <t hangText='FF_ERR_EIO'>
          indicates the operation failed because the Data Server
          experienced a failure trying to access the object.  The
          most common source of these errors is media errors, but
          other internal errors might cause this as well.  In this
          case, the metadata server should go examine the broken
          object more closely; hence, it should be used as the
          default error code.
        </t>

        <t hangText='FF_ERR_NOT_FOUND'>
          indicates the object ID specifies a Component Object that
          does not exist on the Data Server.
        </t>

        <t hangText='FF_ERR_NO_SPACE'>
          indicates the operation failed because the Data Server
          ran out of free capacity during the operation.
        </t>

        <t hangText='FF_ERR_BAD_STATEID'>
          indicates the stateid is not valid.
        </t>

        <t hangText='FF_ERR_NO_ACCESS'>
          indicates the RPC credentials do not allow the requested
          operation.  This may happen when the client is fenced
          off.  The client will need to return the layout and get
          a new one with fresh credentials.
        </t>

        <t hangText='FF_ERR_UNREACHABLE'>
          indicates the client did not complete the I/O operation
          at the Data Server due to a communication failure.  Whether
          or not the I/O operation was executed by the Data Server
          is undetermined.
        </t>

        <t hangText='FF_ERR_RESOURCE'>
          indicates the client did not issue the I/O operation due
          to a local problem on the initiator (i.e., client) side,
          e.g., when running out of memory.  The client MUST guarantee
          that the Data Server WRITE operation was never sent.

          <cref anchor='AI2 ' source='TH'>
            Besides not needing an "i.e." followed by an "e.g.",
            is initiator a term we can employ here? Sounds
            very objecty!
          </cref>
        </t>
      </list>
    </t>
  </section>

  <section anchor="ff_ioerr" title="ff_ioerr">
    <figure>
      <artwork>
/// struct ff_ioerr {
///     deviceid4           ffie_deviceid;
///     nfs_fh4             ffie_fhandle;
///     offset4             ffie_comp_offset;
///     length4             ffie_comp_length;
///     bool                ffie_iswrite;
///     ff_errno            ffie_errno;
/// };
///
      </artwork>
    </figure>

    <t>
      The ff_ioerr structure is used to return error indications
      for Component Objects that generated errors during data
      transfers.  These are hints to the metadata server that there
      are problems with that object.  For each error, "ffie_deviceid",
      "ffie_fhandle", "ffie_comp_offset", and "ffie_comp_length"
      represent the Component Object and byte range within the
      object in which the error occurred; "ffie_iswrite" is set to
      "true" if the failed Data Server operation was data modifying,
      and "ffie_errno" represents the type of error.
    </t>

    <t>
      Component byte ranges in the optional ff_ioerr structure
      are used for recovering the object and MUST be set by the
      client to cover all failed I/O operations to the component.
    </t>
  </section>

  <section anchor="ff_iostats" title="ff_iostats">
    <figure>
      <artwork>
/// struct ff_iostats {
///     offset4             ffis_offset;
///     length4             ffis_length;
///     uint32_t            ffis_duration;
///     uint32_t            ffis_rd_count;
///     uint64_t            ffis_rd_bytes;
///     uint32_t            ffis_wr_count;
///     uint64_t            ffis_wr_bytes;
/// };
///
      </artwork>
    </figure>

    <t>
      With pNFS, the data transfers are performed directly between the
      pNFS client and the data servers.  Therefore, the metadata server
      has no visibility to the I/O stream and cannot use any statistical
      information about client I/O to optimize data storage location.
      ff_iostats4 MAY be used by the client to report I/O statistics
      back to the metadata server upon returning the layout.  Since it
      is infeasible for the client to report every I/O that used the
      layout, the client MAY identify "hot" byte ranges for which to
      report I/O statistics.  The definition and/or configuration mechanism
      of what is considered "hot" and the size of the reported byte range
      is out of the scope of this document.  It is suggested for client
      implementation to provide reasonable default values and an optional
      run-time management interface to control these parameters.  For
      example, a client can define the default byte range resolution to
      be 1 MB in size and the thresholds for reporting to be 1 MB/second
      or 10 I/O operations per second.  For each byte range, ffis_offset
      and ffis_length represent the starting offset of the range and the
      range length in bytes.  ffis_duration represents the number of seconds
      the reported burst of I/O lasted.  ffis_rd_count, ffis_rd_bytes,
      ffis_wr_count, and ffis_wr_bytes represent, respectively, the number
      of contiguous read and write I/Os and the respective aggregate
      number of bytes transferred within the reported byte range.
    </t>
  </section>

  <section anchor="ff_layoutreturn" title="ff_layoutreturn">
    <figure>
      <artwork>
/// struct ff_layoutreturn {
///     ff_ioerr               fflr_ioerr_report&lt;&gt;;
///     ff_iostats             fflr_iostats_report&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
      When object I/O operations failed, "fflr_ioerr_report&lt;&gt;" is
      used to report these errors to the metadata server as an array of
      elements of type ff_ioerr4.  Each element in the array represents
      an error that occurred on the Component Object identified by
      &lt;ffie_deviceid, ffie_fhandle&gt;.  If no errors are to be reported,
      the size of the fflr_ioerr_report&lt;&gt; array is set to zero.
      The client MAY also use "fflr_iostats_report&lt;&gt;" to report a
      list of I/O statistics as an array of elements of type ff_iostats4.
      Each element in the array represents statistics for a particular
      byte range.  Byte ranges are not guaranteed to be disjoint and MAY
      repeat or intersect.
    </t>
  </section>
</section>
