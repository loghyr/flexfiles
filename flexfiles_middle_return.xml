<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible Files Layout Type Return">
  <t>
    layoutreturn_file4 is used in the LAYOUTRETURN operation
    to convey layout-type specific information to the server.
    It is defined in <xref target="RFC5661" /> as follows:
  </t>

  <figure>
    <artwork>
struct layoutreturn_file4 {
        offset4         lrf_offset;
        length4         lrf_length;
        stateid4        lrf_stateid;
        /* layouttype4 specific data */
        opaque          lrf_body&lt;&gt;;
};

    </artwork>
  </figure>

  <figure>
    <artwork>
union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
        case LAYOUTRETURN4_FILE:
                layoutreturn_file4      lr_layout;
        default:
                void;
};

    </artwork>
  </figure>

  <figure>
    <artwork>
struct LAYOUTRETURN4args {
        /* CURRENT_FH: file */
        bool                    lora_reclaim;
        layoutreturn_stateid    lora_recallstateid;
        layouttype4             lora_layout_type;
        layoutiomode4           lora_iomode;
        layoutreturn4           lora_layoutreturn;
};

    </artwork>
  </figure>

  <t>
    If the lora_layout_type layout type is LAYOUT4_FLEX_FILES, then
    the lrf_body opaque value is defined by the ff_layoutreturn4
    type.  The new type allows the client to report I/O
    error information or layout usage statistics back to the metadata
    server as defined below.
  </t>

  <section anchor="ff_ioerr" title="ff_ioerr">
    <figure>
      <artwork>
/// struct ff_ioerr4 {
///         offset4        ffie_offset;
///         length4        ffie_length;
///         stateid4       ffie_stateid;
///         device_error4  ffie_errors;
/// };
///
      </artwork>
    </figure>

    <t>
      Recall that <xref target='NFSv42' /> defines device_error4 as:
    </t>

    <figure>
      <artwork>
   struct device_error4 {
           deviceid4       de_deviceid;
           nfsstat4        de_status;
           nfs_opnum4      de_opnum;
   };
      </artwork>
    </figure>

    <t>
      The ff_ioerr4 structure is used to return error indications
      for data files that generated errors during data transfers.
      These are hints to the metadata server that there are problems
      with that file.  For each error, ffie_errors.de_deviceid,
      ffie_offset, and ffie_length represent the storage device and
      byte range within the file in which the error occurred;
      ffie_errors represents the operation and type of error. The
      use of device_error4 is described in Section 16.6 of
      <xref target='NFSv42' />.
    </t>
  </section>

  <section anchor="ff_io_latency" title="ff_io_latency">
    <figure>
      <artwork>
/// struct ff_io_latency4 {
///         nfstime4       ffil_min;
///         nfstime4       ffil_max;
///         nfstime4       ffil_avg;
///         uint32_t       ffil_count;
/// };
///
      </artwork>
    </figure>
  </section>

  <section anchor="ff_layoutupdate" title="ff_layoutupdate">
    <figure>
      <artwork>
/// struct ff_layoutupdate4 {
///         netaddr4       ffl_offset;
///         nfs_fh4        ffl_fhandle;
///         ff_io_latency4 ffl_read;
///         ff_io_latency4 ffl_write;
///         uint32_t       ffl_queue_depth;
///         bool           ffl_local;
/// };
///
      </artwork>
    </figure>
  </section>

  <section anchor="ff_iostats" title="ff_iostats">
    <figure>
      <artwork>
/// struct ff_iostats4 {
///         offset4        ffis_offset;
///         length4        ffis_length;
///         stateid4       ffis_stateid;
///         uint32_t       ffis_duration;
///         io_info4       ffis_read;
///         io_info4       ffis_write;
///         deviceid4      ffis_deviceid;
///         layoutupdate4  ffis_layoutupdate;
/// };
///
      </artwork>
    </figure>

    <t>
      <cref anchor='AI12 ' source='TH'>
        Need to get the mirror into the layoutupdate!
      </cref>
    </t>

    <t>
      Recall that <xref target='NFSv42' /> defines io_info4 as:
    </t>

    <figure>
      <artwork>
   struct io_info4 {
           uint32_t        ii_count;
           uint64_t        ii_bytes;
   };
      </artwork>
    </figure>

    <t>
      With pNFS, the data transfers are performed directly between
      the pNFS client and the storage devices.  Therefore, the
      metadata server has no visibility to the I/O stream and cannot
      use any statistical information about client I/O to optimize
      data storage location.  ff_iostats4 MAY be used by the client
      to report I/O statistics back to the metadata server upon
      returning the layout.  Since it is infeasible for the client
      to report every I/O that used the layout, the client MAY
      identify "hot" byte ranges for which to report I/O statistics.
      The definition and/or configuration mechanism of what is
      considered "hot" and the size of the reported byte range is
      out of the scope of this document.  It is suggested for client
      implementation to provide reasonable default values and an
      optional run-time management interface to control these
      parameters.  For example, a client can define the default
      byte range resolution to be 1 MB in size and the thresholds
      for reporting to be 1 MB/second or 10 I/O operations per
      second.  For each byte range, ffis_offset and ffis_length
      represent the starting offset of the range and the range
      length in bytes.  ffis_duration represents the number of
      seconds the reported burst of I/O lasted.  ffis_read.ii_count,
      ffis_read.ii_bytes, ffis_write.ii_count, and ffis_write.ii_bytes
      represent, respectively, the number of contiguous read and
      write I/Os and the respective aggregate number of bytes
      transferred within the reported byte range.

      <cref anchor='AI7 ' source='TH'>
        Need to define whether we are using ffis_layoutupdate or not.
      </cref>

      <cref anchor='AI8 ' source='TH'>
        Actually, ffis_duration might be what we plop down in there.
        In any event, ffis_duration needs some work.
      </cref>
    </t>
  </section>

  <section anchor="ff_layoutreturn" title="ff_layoutreturn">
    <figure>
      <artwork>
/// struct ff_layoutreturn {
///         ff_ioerr4     fflr_ioerr_report&lt;&gt;;
///         ff_iostats4   fflr_iostats_report&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
      When data file I/O operations fail, fflr_ioerr_report&lt;&gt;
      is used to report these errors to the metadata server as an
      array of elements of type ff_ioerr4.  Each element in the
      array represents an error that occurred on the data file
      identified by ffie_errors.de_deviceid.  If no errors are to
      be reported, the size of the fflr_ioerr_report&lt;&gt; array
      is set to zero.  The client MAY also use fflr_iostats_report&lt;&gt;
      to report a list of I/O statistics as an array of elements
      of type ff_iostats4.  Each element in the array represents
      statistics for a particular byte range.  Byte ranges are not
      guaranteed to be disjoint and MAY repeat or intersect.
    </t>
  </section>
</section>
