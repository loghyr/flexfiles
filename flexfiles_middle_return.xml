<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section title="Flexible Files Layout Type Return">
  <t>
    layoutreturn_file4 is used in the LAYOUTRETURN operation
    to convey layout-type specific information to the server.
    It is defined in <xref target="RFC5661" /> as follows:
  </t>

  <figure>
    <artwork>
struct layoutreturn_file4 {
        offset4         lrf_offset;
        length4         lrf_length;
        stateid4        lrf_stateid;
        /* layouttype4 specific data */
        opaque          lrf_body&lt;&gt;;
};

    </artwork>
  </figure>

  <figure>
    <artwork>
union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
        case LAYOUTRETURN4_FILE:
                layoutreturn_file4      lr_layout;
        default:
                void;
};

    </artwork>
  </figure>

  <figure>
    <artwork>
struct LAYOUTRETURN4args {
        /* CURRENT_FH: file */
        bool                    lora_reclaim;
        layoutreturn_stateid    lora_recallstateid;
        layouttype4             lora_layout_type;
        layoutiomode4           lora_iomode;
        layoutreturn4           lora_layoutreturn;
};

    </artwork>
  </figure>

  <t>
    If the lora_layout_type layout type is LAYOUT4_FLEX_FILES, then
    the lrf_body opaque value is defined by the ff_layoutreturn4
    type.
  </t>

  <t>
    The ff_layoutreturn4 type allows the client to report I/O
    error information or layout usage statistics back to the metadata
    server as defined below.
  </t>

  <section anchor="ff_ioerr" title="ff_ioerr">
    <figure>
      <artwork>
/// struct ff_ioerr {
///     deviceid4           ffie_deviceid;
///     nfs_fh4             ffie_fhandle;
///     offset4             ffie_comp_offset;
///     length4             ffie_comp_length;
///     device_error4       ffie_errors;
/// };
///
      </artwork>
    </figure>

    <t>
      <cref anchor='AI3 ' source='TH'>
        Note that ffie_fhandle doesn't work as that should
        be given in the operation!
      </cref>

      The ff_ioerr structure is used to return error indications
      for Component Objects that generated errors during data
      transfers.  These are hints to the metadata server that there
      are problems with that object.  For each error, "ffie_deviceid",
      "ffie_fhandle", "ffie_comp_offset", and "ffie_comp_length"
      represent the Component Object and byte range within the
      object in which the error occurred; "ffie_errors" represents
      the operation and type of error.
    </t>

    <t>
      Component byte ranges in the optional ff_ioerr structure
      are used for recovering the object and MUST be set by the
      client to cover all failed I/O operations to the component.
    </t>
  </section>

  <section anchor="ff_iostats" title="ff_iostats">
    <figure>
      <artwork>
/// struct ff_iostats {
///     offset4             ffis_offset;
///     length4             ffis_length;
///     uint32_t            ffis_duration;
///     uint32_t            ffis_rd_count;
///     uint64_t            ffis_rd_bytes;
///     uint32_t            ffis_wr_count;
///     uint64_t            ffis_wr_bytes;
/// };
///
      </artwork>
    </figure>

    <t>
      With pNFS, the data transfers are performed directly between the
      pNFS client and the storage devices.  Therefore, the metadata server
      has no visibility to the I/O stream and cannot use any statistical
      information about client I/O to optimize data storage location.
      ff_iostats4 MAY be used by the client to report I/O statistics
      back to the metadata server upon returning the layout.  Since it
      is infeasible for the client to report every I/O that used the
      layout, the client MAY identify "hot" byte ranges for which to
      report I/O statistics.  The definition and/or configuration mechanism
      of what is considered "hot" and the size of the reported byte range
      is out of the scope of this document.  It is suggested for client
      implementation to provide reasonable default values and an optional
      run-time management interface to control these parameters.  For
      example, a client can define the default byte range resolution to
      be 1 MB in size and the thresholds for reporting to be 1 MB/second
      or 10 I/O operations per second.  For each byte range, ffis_offset
      and ffis_length represent the starting offset of the range and the
      range length in bytes.  ffis_duration represents the number of seconds
      the reported burst of I/O lasted.  ffis_rd_count, ffis_rd_bytes,
      ffis_wr_count, and ffis_wr_bytes represent, respectively, the number
      of contiguous read and write I/Os and the respective aggregate
      number of bytes transferred within the reported byte range.
    </t>
  </section>

  <section anchor="ff_layoutreturn" title="ff_layoutreturn">
    <figure>
      <artwork>
/// struct ff_layoutreturn {
///     ff_ioerr               fflr_ioerr_report&lt;&gt;;
///     ff_iostats             fflr_iostats_report&lt;&gt;;
/// };
///
      </artwork>
    </figure>

    <t>
      When object I/O operations failed, "fflr_ioerr_report&lt;&gt;" is
      used to report these errors to the metadata server as an array of
      elements of type ff_ioerr4.  Each element in the array represents
      an error that occurred on the Component Object identified by
      &lt;ffie_deviceid, ffie_fhandle&gt;.  If no errors are to be reported,
      the size of the fflr_ioerr_report&lt;&gt; array is set to zero.
      The client MAY also use "fflr_iostats_report&lt;&gt;" to report a
      list of I/O statistics as an array of elements of type ff_iostats4.
      Each element in the array represents statistics for a particular
      byte range.  Byte ranges are not guaranteed to be disjoint and MAY
      repeat or intersect.
    </t>
  </section>
</section>
