<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section anchor="sec:mirror" title="Mirroring">
  <t>
    The Flexible File Layout Type has a simple model in place
    for the mirroring of the file data constrained by a layout
    segment. There is no assumption
    that each copy of the mirror is stored identically on the
    storage devices, i.e., one device might employ compression
    or deduplication on the data. However, the over the wire
    transfer of the file contents MUST appear identical. Note,
    this is a construct of the selected XDR representation that
    each mirrored copy of the layout segment has the same striping pattern
    (see <xref target='fig:ff_layout' />).
  </t>

  <t>
    The metadata server is responsible for determining the number
    of mirrored copies and the location of each mirror. While the
    client may provide a hint to how many copies it wants (see
    <xref target='sec:layout_hint' />), the metadata server can
    ignore that hint and in any event, the client has no means to
    dictate neither the storage device (which also means the coupling
    and/or protocol levels to access the layout segments) nor the location of
    said storage device.
  </t>

  <t>
    The updating of mirrored layout segments is done via client-side mirroring.
    With this approach, the client is responsible for making sure
    modifications get to all copies of the layout segments it is informed
    of via the layout. If a layout segment is being resilvered to a storage
    device, that mirrored copy will not be in the layout. Thus the
    metadata server MUST update that copy until the client is presented
    it in a layout. Also, if the client is writing to the layout segments
    via the metadata server, e.g., using an earlier version
    of the protocol, then the metadata server MUST update all copies
    of the mirror. As seen in <xref target='ss:resilvering' />,
    during the resilvering, the layout is recalled, and the client
    has to make modifications via the metadata server.
  </t>

  <section anchor="ss:select_mirror" title="Selecting a Mirror">
    <t>
      When the metadata server grants a layout to a client, it MAY
      let the client know how fast it expects each mirror to be
      once the request arrives at the storage devices via the
      ffds_efficiency member.  While the algorithms to calculate
      that value are left to the metadata server implementations,
      factors that could contribute to that calculation include
      speed of the storage device, physical memory available to the
      device, operating system version, current load, etc.
    </t>

    <t>
      However, what should not be involved in that calculation is
      a perceived network distance between the client and the storage
      device.  The client is better situated for making that
      determination based on past interaction with the storage
      device over the different available network interfaces between
      the two. I.e., the metadata server might not know about a
      transient outage between the client and storage device because
      it has no presence on the given subnet.
    </t>

    <t>
      As such, it is the client which decides which mirror to access
      for reading the file. The requirements for writing to a mirrored
      layout segments are presented below.
    </t>
  </section>

  <section anchor="ss:write_mirror" title="Writing to Mirrors">
    <t>
      The client is responsible for updating all mirrored copies
      of the layout segments that it is given in the layout.  A
      single failed update is suffcient to fail the entire operation.
      I.e., if all but one copy is updated successfully and the
      last one provides an error, then the client needs to return
      the layout to the metadata server with an error indicating
      that the update failed to that storage device.  If the client
      is updating the mirrors serially, then it SHOULD stop at the
      first error encountered and report that to the metadata server.
      If the client is updating the mirrors in parallel, then it
      SHOULD wait until all storage devices respond such that it
      can report all errors encountered during the update.
    </t>

    <t>
      The metadata server is then responsible for determining if it wants
      to remove the errant mirror from the layout, if the mirror has
      recovered from some transient error, etc.  When the client tries
      to get a new layout, the metadata server informs it of the decision
      by the contents of the layout.  The client MUST NOT make any
      assumptions that the contents of the previous layout will match
      those of the new one.  If it has updates that were not committed,
      it MUST resend those updates to all mirrors.
    </t>
  </section>

  <section anchor="ss:resilvering" title="Metadata Server Resilvering of the File">
    <t>
      The metadata server may elect to create a new mirror of the
      layout segments at any time. This might be to resilver a copy on a storage
      device which was down for servicing, to provide a copy of the
      layout segments on storage with different storage performance characteristics,
      etc. As the client will not be aware of the new mirror and
      the metadata server will not be aware of updates that the
      client is making to the layout segments, the metadata server MUST recall
      the writable layout segment(s) that it is resilvering. If the
      client issues a LAYOUTGET for a writable layout segment which
      is in the process of being resilvered, then the metadata
      server MUST deny that request with a NFS4ERR_LAYOUTTRYLATER.
      The client can then perform the I/O through the metadata server.
    </t>
  </section>
</section>
