<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section anchor="sec:mirror" title="Mirroring">
  <t>
    The flexible file layout type has a simple model in place
    for the mirroring of the file data constrained by a layout
    segment. There is no assumption
    that each copy of the mirror is stored identically on the
    storage devices.  For example, one device might employ compression or
    deduplication on the data. However, the over the wire transfer of
    the file contents MUST appear identical. Note, this is a constraint
    of the selected XDR representation in which each mirrored copy of
    the layout segment has the same striping pattern (see <xref
    target='fig:ff_layout' />).
  </t>

  <t>
    The metadata server is responsible for determining the number
    of mirrored copies and the location of each mirror. While the
    client may provide a hint to how many copies it wants (see
    <xref target='sec:layout_hint' />), the metadata server can
    ignore that hint and in any event, the client has no means to
    dictate neither the storage device (which also means the coupling
    and/or protocol levels to access the layout segments) nor the location of
    said storage device.
  </t>

  <t>
    The updating of mirrored layout segments is done via client-side mirroring.
    With this approach, the client is responsible for making sure
    modifications are made on all copies of the layout segments it is informed
    of via the layout. If a layout segment is being resilvered to a storage
    device, that mirrored copy will not be in the layout. Thus the
    metadata server MUST update that copy until the client is presented
    it in a layout. If the client is writing to the layout segments
    via the metadata server, then the metadata server MUST update all copies
    of the mirror. As seen in <xref target='ss:resilvering' />,
    during the resilvering, the layout is recalled, and the client
    has to make modifications via the metadata server.
  </t>

  <section anchor="ss:select_mirror" title="Selecting a Mirror">
    <t>
      When the metadata server grants a layout to a client, it MAY
      let the client know how fast it expects each mirror to be
      once the request arrives at the storage devices via the
      ffds_efficiency member.  While the algorithms to calculate
      that value are left to the metadata server implementations,
      factors that could contribute to that calculation include
      speed of the storage device, physical memory available to the
      device, operating system version, current load, etc.
    </t>

    <t>
      However, what should not be involved in that calculation is
      a perceived network distance between the client and the storage
      device.  The client is better situated for making that
      determination based on past interaction with the storage
      device over the different available network interfaces between
      the two. I.e., the metadata server might not know about a
      transient outage between the client and storage device because
      it has no presence on the given subnet.
    </t>

    <t>
      As such, it is the client which decides which mirror to access
      for reading the file. The requirements for writing to a mirrored
      layout segments are presented below.
    </t>
  </section>

  <section anchor="ss:write_mirror" title="Writing to Mirrors">
    <t>
      The client is responsible for updating all mirrored copies
      of the layout segments that it is given in the layout.  A single
      failed update is sufficient to fail the entire operation.  If all
      but one copy is updated successfully and the last one provides an
      error, then the client needs to inform the metadata server about the
      error via either LAYOUTRETURN or LAYOUTERROR that the update failed
      to that storage device.  If the client is updating the mirrors
      serially, then it SHOULD stop at the first error encountered and
      report that to the metadata server.  If the client is updating
      the mirrors in parallel, then it SHOULD wait until all storage
      devices respond such that it can report all errors encountered
      during the update.
    </t>

    <t>
      The metadata server is then responsible for determining if it wants
      to remove the errant mirror from the layout, if the mirror has
      recovered from some transient error, etc.  When the client tries
      to get a new layout, the metadata server informs it of the decision
      by the contents of the layout.  The client MUST NOT make any
      assumptions that the contents of the previous layout will match
      those of the new one.  If it has updates that were not committed
      to all mirrors, then it MUST resend those updates to all mirrors.
    </t>

    <t>
      There is no provision in the protocol for the metadata server to
      directly determine that the client has or has not recovered from
      an error. I.e., assume that the storage device was network partitioned
      from the client and all of the copies are successfully updated
      after the error was reported. There is no mechanism for the client
      to report that fact and the metadata server is forced to repair
      the file across the mirror.
    </t>

    <t>
      If the client supports NFSv4.2, it can use LAYOUTERROR and
      LAYOUTRETURN to provide hints to the metadata server about the
      recovery efforts. A LAYOUTERROR on a file is for a non-fatal
      error. A subsequent LAYOUTRETURN without a ff_ioerr4 indicates that
      the client successfully replayed the I/O to all mirrors. Any
      LAYOUTRETURN with a ff_ioerr4 is an error that the metadata server
      needs to repair. The client MUST be prepared for the LAYOUTERROR
      to trigger a CB_LAYOUTRECALL if the metadata server determines it
      needs to start repairing the file.
    </t>
  </section>

  <section anchor="ss:resilvering" title="Metadata Server Resilvering of the File">
    <t>
      The metadata server may elect to create a new mirror of the
      layout segments at any time. This might be to resilver a copy on a
      storage device which was down for servicing, to provide a copy of
      the layout segments on storage with different storage performance
      characteristics, etc. As the client will not be aware of the new
      mirror and the metadata server will not be aware of updates that the
      client is making to the layout segments, the metadata server MUST
      recall the writable layout segment(s) that it is resilvering. If
      the client issues a LAYOUTGET for a writable layout segment which
      is in the process of being resilvered, then the metadata server
      can deny that request with a NFS4ERR_LAYOUTUNAVAILABLE.  The client
      would then have to perform the I/O through the metadata server.
    </t>
  </section>
</section>
